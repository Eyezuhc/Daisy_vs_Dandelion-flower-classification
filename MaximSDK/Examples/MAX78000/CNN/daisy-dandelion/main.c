/*******************************************************************************
* Copyright (C) 2019-2023 Maxim Integrated Products, Inc., All rights Reserved.
*
* This software is protected by copyright laws of the United States and
* of foreign countries. This material may also be protected by patent laws
* and technology transfer regulations of the United States and of foreign
* countries. This software is furnished under a license agreement and/or a
* nondisclosure agreement and may only be used or reproduced in accordance
* with the terms of those agreements. Dissemination of this information to
* any party or parties not specified in the license agreement and/or
* nondisclosure agreement is expressly prohibited.
*
* The above copyright notice and this permission notice shall be included
* in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
* OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
* IN NO EVENT SHALL MAXIM INTEGRATED BE LIABLE FOR ANY CLAIM, DAMAGES
* OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
* OTHER DEALINGS IN THE SOFTWARE.
*
* Except as contained in this notice, the name of Maxim Integrated
* Products, Inc. shall not be used except as stated in the Maxim Integrated
* Products, Inc. Branding Policy.
*
* The mere transfer of this software does not imply any licenses
* of trade secrets, proprietary technology, copyrights, patents,
* trademarks, maskwork rights, or any other form of intellectual
* property whatsoever. Maxim Integrated Products, Inc. retains all
* ownership rights.
*******************************************************************************/

// daisy-dandelion_gen
// This file was @generated by ai8xize.py --test-dir C:\MaximSDK\Examples\MAX78000\CNN --prefix daisy-dandelion_gen --overwrite --checkpoint-file ../ai8x-training/logs/daisy_dandelion/qat_best-quantized.pth.tar --config-file networks/daisy-dandelion-hwc.yaml --sample-input ../ai8x-training/logs/daisy_dandelion/sample_daisy_vs_dandelion.npy --softmax --device MAX78000 --timer 0 --display-checkpoint --verbose --fifo

#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <stdio.h>
#include "mxc.h"
#include "cnn.h"
#include "sampledata.h"
#include "sampleoutput.h"

// Other includes
#include "mxc_device.h"
#include "mxc_sys.h"
#include "fcr_regs.h"
#include "icc.h"
#include "led.h"
#include "tmr.h"
#include "dma.h"
#include "pb.h"
#include "weights.h"
#include "sampledata.h"
#include "mxc_delay.h"
#include "camera.h"
#include "board.h"

// define for image, camera, and ascii art
#define ASCII_ART 
#define IMAGE_SIZE_X 128
#define IMAGE_SIZE_Y 128
#define CAMERA_FREQ (5 * 1000 * 1000)

// RGB565 buffer for TFT
uint8_t data565[IMAGE_SIZE_X * 2];

// Classification layer:
static int32_t ml_data[CNN_NUM_OUTPUTS];
static q15_t ml_softmax[CNN_NUM_OUTPUTS];

// Stopwatch
volatile uint32_t cnn_time;

// Get data 
#ifdef USE_SAMPLEDATA
// Data input: HWC 3x128x128 (49152 bytes total / 16384 bytes per channel):
static const uint32_t input_0[] = SAMPLE_INPUT_0; 
#else
static uint32_t input_0[IMAGE_SIZE_X * IMAGE_SIZE_Y]; // buffer for camera image 
#endif

/*************************************************************/ 
#ifdef ASCII_ART
//char * brightness = "$@B%8&WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\\|()1{}[]?-_+~<>i!lI;:,\"^`'. "; 
// standard
char *brightness = "@%#*+=-:."; // simple
#define RATIO 2 // ratio of scaling down the image to display in ascii

void asciiart(uint8_t *img) {
  int skip_x, skip_y;
  uint8_t r, g, b, Y;
  uint8_t *srcPtr = img;
  int l = strlen(brightness) - 1;

  skip_x = RATIO;
  skip_y = RATIO;
  for(int i = 0; i < IMAGE_SIZE_Y; i++) {
    for(int j = 0; j < IMAGE_SIZE_X; j++) {
      // 0x00bbggrr, convert to [0,255] range
      r = *srcPtr++ ^ 0x80;
      g = *(srcPtr++) ^ 0x80;
      b = *(srcPtr++) ^ 0x80;

      srcPtr++; //skip msb=0x00

      Y = (3 * r + b + 4 * g) >> 3; // simple luminance conversion
      if ((skip_x == RATIO) && (skip_y == RATIO))
        printf("%c", brightness[l - (Y * l / 255)]);

      skip_x++;
      if (skip_x > RATIO)
        skip_x = 1;
    }
      skip_y++;
        if (skip_y > RATIO) {
        printf("\n");
        skip_y = 1;
    }
  }
  printf("\n");
}
#endif

/*************************************************************/
void fail(void){
  printf("\n*** FAIL ***\n\n");
  while (1);
}

// Fixed load_input with timeout
void load_input(void){
  int i;
  const uint32_t *in0 = input_0;

  for (i = 0; i < 16384; i++) {
    // Add timeout to prevent infinite hang
    uint32_t timeout = 1000000;
    while (((*((volatile uint32_t *) 0x50000004) & 1)) != 0) {
      if (timeout-- == 0) {
        printf("ERROR: FIFO timeout at word %d! CNN may not be ready.\n", i);
        return;
      }
    }
    
    *((volatile uint32_t *) 0x50000008) = *in0++;
  }
}

/*************************************************************/
int capture_process_camera(void){
  uint8_t *raw;
  uint32_t imgLen;
  uint32_t w, h;
  int cnt = 0;
  uint8_t r, g, b;
  uint16_t rgb;
  int j = 0;
  uint8_t *data = NULL;
  stream_stat_t *stat;
  
  printf("Starting camera capture...\n");
  LED_On(LED1);
  
  camera_start_capture_image();

  // Get the details of the image from the camera driver.
  camera_get_image(&raw, &imgLen, &w, &h);
  printf("Image: W:%d H:%d L:%d\n", w, h, imgLen);

  if (w != IMAGE_SIZE_X || h != IMAGE_SIZE_Y) {
    printf("ERROR: Image size mismatch! Expected %dx%d, got %dx%d\n", 
           IMAGE_SIZE_X, IMAGE_SIZE_Y, w, h);
    LED_Off(LED1);
    return -1;
  }

  // Get image line by line
  for(int row = 0; row < h; row++) {
    // Wait until camera streaming buffer is full
    uint32_t stream_timeout = 5000000;
    while ((data = get_camera_stream_buffer()) == NULL) {
      if (camera_is_image_rcv()) {
        break;
      }
      if (stream_timeout-- == 0) {
        printf("ERROR: Camera stream timeout at row %d!\n", row);
        LED_Off(LED1);
        return -1;
      }
    }
    
    if (data == NULL) {
      printf("ERROR: No camera data received for row %d!\n", row);
      LED_Off(LED1);
      return -1;
    }
    
    j = 0;
    for(int k = 0; k < 4 * w; k += 4) {
      // data format: 0x00bbggrr
      r = data[k];
      g = data[k + 1];
      b = data[k + 2];
      //skip k+3
      
      // change the range from [0,255] to [-128,127] and store in buffer for CNN
      input_0[cnt++] = ((b << 16) | (g << 8) | r) ^ 0x00808080;
      
      // convert to RGB565 for display
      rgb = ((r & 0b11111000) << 8) | ((g & 0b11111100) << 3) | (b >> 3);
      data565[j] = (rgb >> 8) & 0xFF;
      data565[j + 1] = rgb & 0xFF;
      j += 2;
    }
    
    // Release stream buffer
    release_camera_stream_buffer();
  }
  
  printf("Camera capture completed, %d pixels processed\n", cnt);
  LED_Off(LED1);
  
  stat = get_camera_stream_statistic();
  if (stat->overflow_count > 0) {
    printf("CAMERA OVERFLOW = %d\n", stat->overflow_count);
    LED_On(LED2);
  }
  
  return 0;
}

/********************************************************/
void softmax_layer(void){
  cnn_unload((uint32_t *) ml_data);
  softmax_q17p14_q15((const q31_t *) ml_data, CNN_NUM_OUTPUTS, ml_softmax);
}

// CNN Done interrupt handler
void CNN_IRQHandler(void){
  cnn_disable();
  cnn_time = *((volatile uint32_t*) 0x500000a0);
}

int main(void){
  int i;
  int digs, tens;
  int ret = 0;
  int result[CNN_NUM_OUTPUTS];
  int dma_channel;

  // Classes - Updated for daisy vs dandelion
  const char classes[CNN_NUM_OUTPUTS][20] = {"Daisy", "Dandelion"};
  
#if defined(BOARD_FTHR_REVA)
  // Wait for PMIC 1.8V to become available, about 180ms after power up.
  MXC_Delay(200000);
  
  /* Enable camera power */
  Camera_Power(POWER_ON);
  MXC_Delay(100000); // Additional delay for camera power stabilization
  
  printf("\n\n======================================\n");
  printf("   Daisy vs Dandelion Flower Detector\n");
  printf("   MAX78000 Feather Board\n");
  printf("======================================\n\n");
#endif

  // Enable cache
  MXC_ICC_Enable(MXC_ICC0);

  // Switch to 100 MHz clock
  MXC_SYS_Clock_Select(MXC_SYS_CLOCK_IPO);
  SystemCoreClockUpdate();

  printf("System initialized at %lu Hz\n", SystemCoreClock);
  printf("Waiting 2 seconds for debugger...\n");
  MXC_Delay(SEC(2));

  // Initialize push button
  PB_Init();
  
  // Initialize LEDs
  LED_Init();
  LED_Off(LED1);
  LED_Off(LED2);

/****************************************************/
  // For Camera Initialization
  printf("Initializing DMA for camera...\n");
  MXC_DMA_Init();
  dma_channel = MXC_DMA_AcquireChannel();
  
  if (dma_channel < 0) {
    printf("ERROR: Failed to acquire DMA channel!\n");
    fail();
  }
  printf("Acquired DMA channel: %d\n", dma_channel);

  // Initialize camera.
  printf("Initializing camera at %d Hz...\n", CAMERA_FREQ);
  ret = camera_init(CAMERA_FREQ);
  
  if (ret != STATUS_OK) {
    printf("ERROR: Camera initialization failed! Code: %d\n", ret);
    printf("Check camera connections and power.\n");
    fail();
  }
  printf("Camera init successful\n");

  ret = camera_setup(IMAGE_SIZE_X, IMAGE_SIZE_Y, PIXFORMAT_RGB888, 
                     FIFO_THREE_BYTE, STREAMING_DMA, dma_channel);
  
  if (ret != STATUS_OK) {
    printf("ERROR: Camera setup failed! Code: %d\n", ret);
    printf("Possible causes:\n");
    printf("1. Wrong image size\n");
    printf("2. Unsupported pixel format\n");
    printf("3. DMA configuration error\n");
    fail();
  }
  printf("Camera setup completed\n");

  // Set camera clock prescaler to prevent streaming overflow
  camera_write_reg(0x11, 0x0);
  printf("Camera configured for %dx%d RGB888\n", IMAGE_SIZE_X, IMAGE_SIZE_Y);

/****************************************************/
  // Enable peripheral, enable CNN interrupt, turn on CNN clock
  // CNN clock: APB (50 MHz) div 1
  cnn_enable(MXC_S_GCR_PCLKDIV_CNNCLKSEL_PCLK, MXC_S_GCR_PCLKDIV_CNNCLKDIV_DIV1);

  printf("\n*** CNN Inference Test - Daisy vs Dandelion ***\n");

  cnn_init(); // Bring state machine into consistent state
  cnn_load_weights(); // Load kernels
  cnn_load_bias();
  cnn_configure(); // Configure state machine

  printf("CNN initialized with %d output classes\n", CNN_NUM_OUTPUTS);

/****************************************************/
  printf("\n======================================\n");
  printf("READY FOR FLOWER DETECTION\n");
  printf("Press SW1 (PB1) to capture and analyze\n");
  printf("======================================\n\n");

  // Enable CNN clock
  MXC_SYS_ClockEnable(MXC_SYS_PERIPH_CLOCK_CNN);

  while (1) {
    // Wait for button press
    printf("Waiting for button press...\n");
    while (!PB_Get(0)) {
      // Optional: Add LED blinking to show ready state
      LED_Toggle(LED1);
      MXC_Delay(100000);
    }
    
    // Debounce button
    MXC_Delay(50000);
    while (PB_Get(0)) {} // Wait for button release
    MXC_Delay(50000);
    
    LED_Off(LED1);
    LED_Off(LED2);
    
    printf("\n--- Starting Flower Detection Cycle ---\n");
    
    // 1. Capture image from camera
    printf("1. Capturing image...\n");
    ret = capture_process_camera();
    
    if (ret != 0) {
      printf("ERROR: Camera capture failed!\n");
      LED_On(LED2); // Red LED for error
      continue; // Skip to next iteration
    }
    
    // 2. Start CNN processing
    printf("2. Starting CNN inference...\n");
    cnn_time = 0;
    cnn_start(); // Start CNN processing
    
    // 3. Load image data to CNN
    printf("3. Loading image to CNN...\n");
    load_input(); // Load data input via FIFO

    // 4. Wait for CNN to complete
    printf("4. Waiting for CNN completion...\n");
    SCB->SCR &= ~SCB_SCR_SLEEPDEEP_Msk; // SLEEPDEEP=0
    
    uint32_t cnn_timeout = 10000000; // 10 second timeout
    while (cnn_time == 0) {
      __WFI(); // Wait for CNN interrupt
      if (cnn_timeout-- == 0) {
        printf("ERROR: CNN inference timeout!\n");
        cnn_disable();
        break;
      }
    }
    
    if (cnn_time == 0) {
      printf("CNN failed to complete\n");
      continue;
    }
    
    printf("CNN inference completed in %u us\n", cnn_time);

    // 5. Process results with softmax
    printf("5. Processing results...\n");
    softmax_layer();

    // 6. Display results
    printf("\n=== FLOWER DETECTION RESULTS ===\n");
    int max_index = 0;
    q15_t max_confidence = 0;
    
    for (i = 0; i < CNN_NUM_OUTPUTS; i++) {
      digs = (1000 * ml_softmax[i] + 0x4000) >> 15;
      tens = digs % 10;
      digs = digs / 10;
      result[i] = digs;
      
      printf("  %-12s: %d.%d%%\n", classes[i], result[i], tens);
      
      // Find highest confidence
      if (ml_softmax[i] > max_confidence) {
        max_confidence = ml_softmax[i];
        max_index = i;
      }
    }
    
    // Display final decision
    printf("\n>>> DETECTED: %s (%.1f%% confidence) <<<\n", 
           classes[max_index], 
           result[max_index] + (tens/10.0));
    
    // Visual feedback with LEDs
    if (max_index == 0) { // Daisy
      LED_On(LED1); // Green LED for Daisy
      LED_Off(LED2);
    } else { // Dandelion
      LED_On(LED2); // Red LED for Dandelion
      LED_Off(LED1);
    }

    // 7. Display ASCII art if enabled
    #ifdef ASCII_ART
      printf("\n--- Camera Image (ASCII Art) ---\n");
      asciiart((uint8_t *)input_0);
    #endif
    
    printf("\n======================================\n");
    printf("Press SW1 (PB1) to capture another image\n");
    printf("======================================\n\n");
    
    // Wait a moment before allowing another capture
    MXC_Delay(500000);
  }
  
  return 0;
}